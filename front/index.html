<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Обработка изображений</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    input[type="file"] {
      margin-bottom: 20px;
    }
    .preview {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .preview img {
      max-width: 150px;
      max-height: 150px;
      border: 1px solid #ccc;
      padding: 5px;
    }
    .file-info {
      margin-top: 10px;
      font-size: 0.9em;
      color: #333;
    }
    .file-entry {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Загрузка и обработка изображений</h1>
  <input type="file" id="fileInput" accept="image/*" multiple />
  <div class="preview" id="preview"></div>
  <div class="file-info" id="fileInfo"></div>

  <script type="module">
    // Копируем ваши функции
    const generateUniqueImageName = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    };

    const resizeImage = (img, maxWidth, quality) => {
  return new Promise((resolve) => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    if (!ctx) {
      throw new Error("К сожаление, мы не поддерживаем вашу версию браузера");
    }

    // Ограничение на максимальное количество пикселей
    const MAX_PIXELS = 2000 * 2000;
    let width = img.width;
    let height = img.height;
    const scaleFactor = maxWidth / width;

    width = img.width * scaleFactor;
    height = img.height * scaleFactor;

    // Защита от слишком больших изображений
    if (width * height > MAX_PIXELS) {
      const scale = Math.sqrt(MAX_PIXELS / (img.width * img.height));
      width = img.width * scale;
      height = img.height * scale;
    }

    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, 0, 0, width, height);

    let attempts = 0;
    const maxAttempts = 10;

    const tryCompress = (qual) => {
      if (attempts++ > maxAttempts) {
        canvas.width = 0;
        canvas.height = 0;
        resolve(blob);
        return;
      }

      canvas.toBlob(
        (blob) => {
          if (!blob) {
            canvas.width = 0;
            canvas.height = 0;
            resolve(blob);
            return;
          }

          if (blob.size <= 1_000_000 || qual < 10) {
            canvas.width = 0;
            canvas.height = 0;
            resolve(blob);
          } else {
            tryCompress(Math.max(qual - 10, 10));
          }
        },
        "image/webp",
        qual / 100
      );
    };

    tryCompress(Math.min(Math.max(quality, 10), 100));
  });
};

    const createImageVersions = async (file) => {
      const versions = [];

      const image = await new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
          URL.revokeObjectURL(url);
          resolve(img);
        };

        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error(`Failed to load image: ${file.name}`));
        };

        img.src = url;
      });

      const uniqName = generateUniqueImageName();

      versions.push(
        new File([await resizeImage(image, 1920, 80)], `${uniqName}-original.webp`, { type: "image/webp" }),
        new File([await resizeImage(image, 960, 90)], `${uniqName}-medium.webp`, { type: "image/webp" }),
        new File([await resizeImage(image, 480, 95)], `${uniqName}-low.webp`, { type: "image/webp" })
      );

      return versions;
    };

    const processImageFiles = async (files) => {
      const MAX_MAIN_FILES = 15;
      const mainFiles = [];
      const additionalFiles = [];
      const filesOrder = [];

      for (let i = 0; i < files.length; i++) {
        const file = files[i];

        try {
          const startTime = performance.now();
          const versions = await createImageVersions(file);
          const duration = performance.now() - startTime;

          if (mainFiles.length < MAX_MAIN_FILES) {
            mainFiles.push(...versions);
          } else {
            additionalFiles.push(...versions);
            filesOrder.push(versions[0].name.replace(/\.[^/.]+$/, ""));
          }

          // Сохраняем статистику
          versions.forEach((v) => {
            file._processedStats = file._processedStats || [];
            file._processedStats.push({
              name: v.name,
              originalSizeKB: (file.size / 1024).toFixed(2),
              processedSizeKB: (v.size / 1024).toFixed(2),
              durationMS: duration.toFixed(0),
            });
          });
        } catch (error) {
          console.error(`Ошибка обработки: ${error}`);
        }
      }

      return { mainFiles, additionalFiles, filesOrder };
    };

    const createImagesFormDataToUpload = async (adId, formData) => {
      const photoFields = ["mainPhoto", "secondPhoto", "thirdPhoto", "fourthPhoto", "fifthPhoto"];
      const uploadFormData = new FormData();
      uploadFormData.append("adId", adId);

      const files = [];
      formData.forEach((value) => {
        if (value instanceof File && value.type.startsWith("image/")) {
          files.push(value);
        }
      });

      if (files.length === 0) {
        console.warn("Внимание: не найдено ни одного изображения!");
        throw new Error("No image files found in FormData");
      }

      const { mainFiles, additionalFiles, filesOrder } = await processImageFiles(files);

      for (let i = 0; i < mainFiles.length; i++) {
        const fieldIndex = Math.floor(i / 3);
        if (fieldIndex < photoFields.length) {
          uploadFormData.append(photoFields[fieldIndex], mainFiles[i]);
        }
      }

      additionalFiles.forEach((file) => {
        uploadFormData.append("files", file);
      });

      if (filesOrder.length > 0) {
        uploadFormData.append("filesOrder", filesOrder.join(","));
      }

      return { formData: uploadFormData, fileStats: files.map(f => f._processedStats || []) };
    };

    // Обработка загрузки
    document.getElementById("fileInput").addEventListener("change", async (e) => {
      const files = Array.from(e.target.files);
      if (files.length === 0) return;

      const formData = new FormData();
      files.forEach((file) => formData.append("images", file));

      try {
        const result = await createImagesFormDataToUpload("test-ad-id", formData);
        const { formData: resultFormData, fileStats } = result;

        const preview = document.getElementById("preview");
        const fileInfo = document.getElementById("fileInfo");
        preview.innerHTML = "";
        fileInfo.innerHTML = "";

        // Показываем превью
        for (const [key, file] of resultFormData.entries()) {
          if (file instanceof File) {
            const url = URL.createObjectURL(file);
            const img = document.createElement("img");
            img.src = url;
            img.alt = file.name;
            img.title = `${file.name} (${file.size} байт, ${file.type})`;
            preview.appendChild(img);
          }
        }

        // Показываем статистику по файлам
        fileStats.forEach((stats) => {
          stats.forEach((stat) => {
            const div = document.createElement("div");
            div.className = "file-entry";
            div.innerHTML = `
              <strong>${stat.name}</strong><br>
              До обработки: ${stat.originalSizeKB} KB<br>
              После обработки: ${stat.processedSizeKB} KB<br>
              Время обработки: ${stat.durationMS} мс
            `;
            fileInfo.appendChild(div);
          });
        });
      } catch (err) {
        alert("Ошибка при обработке изображений");
        console.error(err);
      }
    });
  </script>
</body>
</html>